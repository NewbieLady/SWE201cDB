The logical (intended) dependency is that observer depends on subject.|True
Up until now, the great state of Foo has held a lottery to help fund education in the state. The corporation tasked with the drawing of these numbers (the non-televised ones) is XYZ Numerical Tasking. You are the technical lead for the system which handles the drawings for the state's lotteries. One of your developers, with a mathematical tilt, comes to you with a proposal: change how the random numbers are generated. He suggests that the generation of random numbers could be better. NASA has released a random number generator which has been proven to be better than the one used by the company. He suggests that you make the change. One of your more senior developers notes that using the new generator will require a change. He suggests that the team connect the existing lotto system, as seen in Figure 1, to the new generator (Figure 2) using the Facade pattern. Figure 1 Figure 2 Facade, which seeks to simplify complex processes for a client by providing a API which hides the complicated calls/work needed, doesn't seem to fit. What pattern does?|Adapter Pattern
Within the Custodial Management System, there are are a variety of items that are being watched at any given time. Certain items can receive notifications that a response is needed immediately (rather than just tracking whether the regular upkeep has been done that week/month/etc.). These items may then need one of several possible actions: rapid cleaning, bodily fluid containment and/or removal, addressing traction/slip-danger, urgent repair, etc. Each of these actions fit the same profile (action) but not necessarily the same steps. Which pattern would fit well as a solution to this systems needs?|Observer Pattern
Early in our proof-of-concept work on the new game we are building, we effectively hard-coded the game to ask the user what action to take next, for both players. In this case, both users are tied into a single account, so that we can play against ourselves while we build out the game. Now, however, we want to add a new player type to the system, EasyDifficultyBot. While the "player" actions fit the same high-level format for both humans and our AI, the details of making it happen vary pretty widely. In order to allow for this change, we want to make use of a pattern that will allow this kind of expansion while minimizing changes to the existing code. What pattern would be best here?|Strategy Pattern
Consider the statement "In the Strategy pattern, the context should hold references to the ConcreteStrategies." Under what circumstances would this be true? Select all that apply.|When the context is tasked with deciding which strategy to use
In the Observer pattern, one difficulty is that the Subject cannot pass an instance of itself to the Observer being updated, due to circular dependencies.|False
Once a class has been had an Adapter pattern solution applied, it cannot be adapted again.|False
Factories are no longer useful when you apply the Strategy Pattern to a family of algorithms.|False
Observer is an implementation of the Dependency Inversion principle.|True
Strategy Pattern helps maintain the Open/Closed Principle.|True
Notes: For questions 11-14, the diagram is a standard UML Class Diagram. You can view a larger version by right clicking and selecting "View image" (or similar) or by holding on the image and selecting "Open image in new tab" (or similar) if you're on mobile. Use up to 3 significant digits (e.g. .5 for 1/2 and .333 for 1/3 are acceptable). For the following class diagram, calculate the Instability value for the Bus class.|0.714
For the following class diagram, calculate the Instability value for the Stop class. Use up to 3 significant digits (e.g. .5 for 1/2 and .333 for 1/3 are acceptable).|0.333
For the following class diagram, calculate the Instability value for the PassengerUnloader class. Use up to 3 significant digits (e.g. .5 for 1/2 and .333 for 1/3 are acceptable).|0.5
For the following class diagram, calculate the Instability value for the Simulator class. Use up to 3 significant digits (e.g. .5 for 1/2 and .333 for 1/3 are acceptable). (Hint: LocalSimulator depends on Simulator; which type of coupling is this?) Note: Simulator does not depend on ConfigManager; the arrow should go by it on its way to Stop.|
While calculating LCOM4, we ignore constructors and destructors. Constructors and destructors frequently set and clear all variables in the class, making all methods connected through these variables, which increases cohesion artificially. LCOM4 = 1 indicates a cohesive class, which is the "good" class. LCOM4 >= 2 indicates a problem. The class should be split into so many smaller classes. LCOM4 = 0 happens when there are no methods in a class. This is also a "bad" class. Calculate the value of the LCOM4 measurement for the following code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include "src/route.h" Route::Route(std::string name, Stop ** stops, double * distances, int num_stops, PassengerGenerator * generator) { //Constructors ignored in LCOM4 calculation } void Route::Update() { GenerateNewPassengers(); for (std::list<Stop *>::iterator it = stops_.begin(); it != stops_.end(); it++) { (*it)->Update(); } } bool Route::IsAtEnd() const { return destination_stop_index_ >= num_stops_; } void Route::NextStop() { destination_stop_index_++; if (destination_stop_index_ < num_stops_) { std::list<Stop *>::const_iterator iter = stops_.begin(); std::advance(iter, destination_stop_index_); destination_stop_ = *iter; } else { destination_stop_ = (*stops_.end()); } } Stop * Route::GetDestinationStop() const { return destination_stop_; } double Route::GetTotalRouteDistance() const { int total_distance = 0; for (std::list<double>::const_iterator iter = distances_between_.begin(); iter != distances_between_.end(); iter++) { total_distance += *iter;|2
Cyclomatic complexity is calculated by the formula: M = E − N + 2P, where E = the number of edges of the graph. N = the number of nodes of the graph. P = the number of connected components . Calculate the cyclomatic complexity for the following control flow graph:|3
Cyclomatic complexity is calculated by the formula: M = E − N + 2P, where E = the number of edges of the graph. N = the number of nodes of the graph. P = the number of connected components . Calculate the cyclomatic complexity for the following control flow graph:|4
Cyclomatic complexity is calculated by the formula: M = E − N + 2P, where E = the number of edges of the graph. N = the number of nodes of the graph. P = the number of connected components . Calculate the cyclomatic complexity for the following control flow graph:|4
